use std::sync::Arc;
use tokio::sync::RwLock;
use tonic::{Request, Response, Status};
use tracing::{info, error, debug};

use proto::{
    RequestVoteRequest, RequestVoteResponse,
    AppendEntriesRequest, AppendEntriesResponse,
    InstallSnapshotRequest, InstallSnapshotResponse,
    SubmitCommandRequest, SubmitCommandResponse,
    GetStatusRequest, GetStatusResponse,
    NodeState as ProtoNodeState,
};

use raft_core::{RaftNode, NodeState};
use state::{StateMachine, InMemoryKvStore};
use state::state_machine::Command;
use crate::config::ServerConfig;
use crate::metrics::RaftMetrics;
use crate::error::ServerError;

/// gRPC server implementation for Raft
pub struct RaftGrpcServer {
    raft_node: Arc<RwLock<RaftNode>>,
    state_machine: Arc<RwLock<dyn StateMachine>>,
    config: ServerConfig,
    metrics: RaftMetrics,
}

impl RaftGrpcServer {
    /// Create a new gRPC server
    pub fn new(config: ServerConfig) -> Result<Self, ServerError> {
        let node_config = raft_core::NodeConfig {
            node_id: config.node_id.clone(),
            address: config.server_address(),
            peers: config.peers.clone(),
            election_timeout_min: config.election_timeout_min,
            election_timeout_max: config.election_timeout_max,
            heartbeat_interval: config.heartbeat_interval,
        };
        
        let raft_node = Arc::new(RwLock::new(RaftNode::new(node_config)));
        let state_machine: Arc<RwLock<dyn StateMachine>> = Arc::new(RwLock::new(InMemoryKvStore::new()));
        let metrics = RaftMetrics::new().map_err(|e| ServerError::Configuration(e.to_string()))?;
        
        Ok(Self {
            raft_node,
            state_machine,
            config,
            metrics,
        })
    }
    
    /// Get the gRPC service (placeholder for now)
    pub fn service(&self) -> Self {
        self.clone()
    }

    /// Get metrics for external access
    pub fn get_metrics(&self) -> &RaftMetrics {
        &self.metrics
    }
    
    /// Convert Raft NodeState to Proto NodeState
    fn convert_node_state(state: NodeState) -> ProtoNodeState {
        match state {
            NodeState::Follower => ProtoNodeState::Follower,
            NodeState::Candidate => ProtoNodeState::Candidate,
            NodeState::Leader => ProtoNodeState::Leader,
        }
    }
}

impl Clone for RaftGrpcServer {
    fn clone(&self) -> Self {
        Self {
            raft_node: Arc::clone(&self.raft_node),
            state_machine: Arc::clone(&self.state_machine),
            config: self.config.clone(),
            metrics: self.metrics.clone(),
        }
    }
}

// Placeholder implementation - would be generated by tonic
impl RaftGrpcServer {
    pub async fn handle_request_vote(
        &self,
        request: Request<RequestVoteRequest>,
    ) -> Result<Response<RequestVoteResponse>, Status> {
        let req = request.into_inner();
        self.metrics.vote_requests_total.inc();
        
        info!("Received vote request from candidate: {}", req.candidate_id);
        
        let vote_request = raft_core::VoteRequest {
            term: req.term,
            candidate_id: req.candidate_id,
            last_log_index: req.last_log_index,
            last_log_term: req.last_log_term,
        };
        
        let mut node = self.raft_node.write().await;
        match node.handle_vote_request(vote_request) {
            Ok(vote_response) => {
                let response = RequestVoteResponse {
                    term: vote_response.term,
                    vote_granted: vote_response.vote_granted,
                };
                Ok(Response::new(response))
            }
            Err(e) => {
                error!("Error handling vote request: {}", e);
                Err(Status::internal(e.to_string()))
            }
        }
    }
    
    pub async fn handle_append_entries(
        &self,
        request: Request<AppendEntriesRequest>,
    ) -> Result<Response<AppendEntriesResponse>, Status> {
        let req = request.into_inner();
        self.metrics.append_requests_total.inc();
        
        // Convert proto entries to raft entries
        let entries = req.entries.into_iter().map(|entry| {
            raft_core::LogEntry {
                index: entry.index,
                term: entry.term,
                entry_type: match entry.entry_type {
                    0 => raft_core::EntryType::Command,
                    1 => raft_core::EntryType::Configuration,
                    2 => raft_core::EntryType::NoOp,
                    _ => raft_core::EntryType::Command,
                },
                data: entry.data,
                client_id: if entry.client_id.is_empty() { None } else { Some(entry.client_id) },
                sequence_number: if entry.sequence_number == 0 { None } else { Some(entry.sequence_number) },
            }
        }).collect();
        
        let append_request = raft_core::AppendRequest {
            term: req.term,
            leader_id: req.leader_id,
            prev_log_index: req.prev_log_index,
            prev_log_term: req.prev_log_term,
            entries,
            leader_commit: req.leader_commit,
        };
        
        let mut node = self.raft_node.write().await;
        match node.handle_append_request(append_request) {
            Ok(append_response) => {
                let response = AppendEntriesResponse {
                    term: append_response.term,
                    success: append_response.success,
                    conflict_index: append_response.conflict_index.unwrap_or(0),
                    conflict_term: append_response.conflict_term.unwrap_or(0),
                };
                Ok(Response::new(response))
            }
            Err(e) => {
                error!("Error handling append entries: {}", e);
                Err(Status::internal(e.to_string()))
            }
        }
    }
    
    pub async fn handle_install_snapshot(
        &self,
        request: Request<InstallSnapshotRequest>,
    ) -> Result<Response<InstallSnapshotResponse>, Status> {
        let req = request.into_inner();
        info!("Received install snapshot request from leader: {}", req.leader_id);
        
        // TODO: Implement snapshot installation
        let response = InstallSnapshotResponse {
            term: req.term,
        };
        
        Ok(Response::new(response))
    }
    
    pub async fn handle_submit_command(
        &self,
        request: Request<SubmitCommandRequest>,
    ) -> Result<Response<SubmitCommandResponse>, Status> {
        let req = request.into_inner();
        self.metrics.commands_total.inc();
        
        info!("Received command submission from client: {}", req.client_id);
        
        // TODO: Implement command submission logic
        let response = SubmitCommandResponse {
            success: false,
            error: "Not implemented yet".to_string(),
            result: Vec::new(),
            leader_id: "".to_string(),
        };
        
        Ok(Response::new(response))
    }
    
    pub async fn handle_get_status(
        &self,
        _request: Request<GetStatusRequest>,
    ) -> Result<Response<GetStatusResponse>, Status> {
        let node = self.raft_node.read().await;
        
        let response = GetStatusResponse {
            state: Self::convert_node_state(node.state()) as i32,
            current_term: node.current_term(),
            node_id: node.node_id().clone(),
            leader_id: "".to_string(), // TODO: Track current leader
            commit_index: 0, // TODO: Get from node
            last_applied: 0, // TODO: Get from node
            log_length: 0, // TODO: Get from node
            peers: self.config.peers.clone(),
        };
        
        Ok(Response::new(response))
    }
}
